# 找到所有数组中消失的数字

> <https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/description/>

给你一个含 `n` 个整数的数组 `nums` ，其中 `nums[i]` 在区间 `[1, n]` 内。请你找出所有在 `[1, n]` 范围内但没有出现在 `nums` 中的数字，并以数组的形式返回结果。

**示例 1：**

输入：nums = \[4,3,2,7,8,2,3,1]
输出：\[5,6]

**示例 2：**

输入：nums = \[1,1]
输出：\[2]

**提示：**

*   `n == nums.length`
*   `1 <= n <= 10`^5^
*   `1 <= nums[i] <= n`

进阶：*你能在不使用额外空间且时间复杂度为* *`O(n)`* 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。

## 题解

这个题目表达的问题就是比如示例1的数组, 长度为8, 表示应该有8个数字, 理论上应该是从1到8, 实际上2跟3出现了两次. 这里需要找到丢失的数字4和5.

在这里我们可以对数组进行遍历, 把当前遍历的值对应的数组下标值给加一个数组的长度, 比如此数组为4,3,2,7,8,2,3,1  遍历到4 就给nums\[4-1]的值加上nums.length  就是7+8 = 15

在遍历到第四位的时候, 因为最开始已经给7改成了15, 所以这里要还原本来的数字, 取值就可以使用(n - 1) & nums.length 就可以给15还原成 7 - 1, 不然会数组下标越界

8次循环数组内的元素变化如下:

```java

//原数组如下, 长度为8
[4,3,2,7,8,2,3,1]

// 第一次 数字是4 修改第四位 7 + 8 = 15
[4, 3, 2, 15, 8, 2, 3, 1] 
// 第二次 数字是3 修改第三位 2 + 8 = 10
[4, 3, 10, 15, 8, 2, 3, 1]
// 第三次 数字是10 这里需要还原本来的数字 所以用 10 % 8 就可以还原本来的数字是 2 修改第二位 3 + 8 = 11
[4, 11, 10, 15, 8, 2, 3, 1]
// 以此类推 剩下5次结果如下
[4, 11, 10, 15, 8, 2, 11, 1]
[4, 11, 10, 15, 8, 2, 11, 9]
[4, 19, 10, 15, 8, 2, 11, 9]
[4, 19, 18, 15, 8, 2, 11, 9]
[12, 19, 18, 15, 8, 2, 11, 9]
```

这样一圈下来之后, 这个数组中如果有小于等于数组长度的数字, 那么他的下标+1就会是缺失的那位数字.

比如第一圈之后, 数组中的数字为 \[12, 19, 18, 15, 8, 2, 11, 9]  这里就可以看出来第五位第六位是小于等于数组长度的,  所以返回\[5,6]即可.

## 代码

```java
	/**
     * 思路：遍历数组，将每个元素对应的下标位置的值加上数组长度，然后遍历数组，如果某个元素对应的下标位置的值小于等于数组长度，则说明该元素没有出现过，将其加入结果列表中
     */
    public static List<Integer> findDisappearedNumbers(int[] nums) {
        int length = nums.length;
        List<Integer> resultList = new ArrayList<>();
        for (int num : nums) {
            // 这里因为前面可能给当前num已经加了length，所以这里要取模, 还原本来的数字大小
            int index = (num - 1) % length;
            nums[index] += length;
        }
        System.out.println(Arrays.toString(nums));

        // 遍历数组, 找出小于等于数组长度的元素，即为消失的数字
        for (int i = 0; i < length; i++) {
            if (nums[i] <= length) {
                resultList.add(i + 1);
            }
        }
        return resultList;
    }
```

