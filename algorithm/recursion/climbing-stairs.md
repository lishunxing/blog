# 爬楼梯

> <https://leetcode.cn/problems/climbing-stairs/description/>

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**
```
    输入：n = 2
    输出：2
    解释：有两种方法可以爬到楼顶。
    1. 1 阶 + 1 阶
    2. 2 阶
```
**示例 2：**
```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶

```

**提示：**

*   `1 <= n <= 45`

## 题解

首先考虑此问题的终止条件, 我们一步只能爬一层或者两层, 所以最终来讲, 当最终剩余楼梯个数 n = 1或者 n=2 的时候, 这一段爬楼过程就终止了

其次我们设定爬楼梯的这个方法名字叫 f, 楼梯总层数为n , 因为每次只能爬一层或者两层, 所以对于这个递归来讲, 假设第一次爬楼梯走的是一层, 那么接下来剩余的层数就是 f(n-1), 如果是两层, 那么剩余的层数就是f(n-2)

由上面2个条件可以看出, 当n = 1的时候, 次数为1, 当 n =2的时候, 次数为2, 当n > 2的时候, 次数就为 f(n-1) + f(n-2)

比如如果n = 3 的时候, 第一步爬了1层, 剩余2层, 此时返回2, 如果第一步爬了2层, 剩余1层, 此时返回1 , 这时候2+1就为3层楼梯可以有3种方法爬到楼顶

**基于以上分析, 可以初步得出如下代码:**

```java
    public static int climbStairs(int n) {
        // 如果只剩1层, 那就只有1种方法
        if (n == 1) {
            return 1;
        }
        // 如果剩2层, 那就有2种方法爬完, 一种爬两次1层, 一种直接爬两层
        if (n == 2) {
            return 2;
        }
        // 剩下的就递归接着爬, 爬完1层, 再爬剩下的, 然后与爬完2层的方法相加
        return climbStairs(n - 1) + climbStairs(n - 2);
    }
```

**分析:**

以上方法已经可以求出答案, 但是此时递归的方法可以看出时间复杂度为n², 假设n为6的情况下, 执行的流程图如下:

![image](https://file.lishunxing.cn/img/爬楼梯.png)

可以看到在计算f(5)的时候, 已经重复计算了f(4)以及以下的步骤, 所以这里可以优化以下, 对于已经计算过的值可以放入一个map中, 存在的话直接拿出来用即可

**优化后的代码如下:**

```java
	/**
     * 优化递归方法 记录已经计算过的结果, 不用重复计算
     */
    private static HashMap<Integer,Integer> recordMap = new HashMap<>();
    public static int climbStairs2(int n) {
        // 判断是否已经计算过, 如果有就直接返回
        if (recordMap.containsKey(n)) {
            return recordMap.get(n);
        }

        // 如果只剩1层, 那就只有1种方法
        if (n == 1) {
            return 1;
        }
        // 如果剩2层, 那就有2种方法爬完, 一种爬两次1层, 一种直接爬两层
        if (n == 2) {
            return 2;
        }
        // 剩下的就递归接着爬, 爬完1层, 再爬剩下的, 然后与爬完2层的方法相加, 这里顺便写入记录
        int result = climbStairs(n - 1) + climbStairs(n - 2);
        recordMap.put(n, result);
        return result;
    }
```

